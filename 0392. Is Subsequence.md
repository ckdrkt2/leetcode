code:

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        for i in s:
            a = t.find(i)
            if a != -1:
                t = t[a+1:]
            else:
                return False
        return True
```
문자열 s의 문자를 문자열 t에서 찾고 인덱스 값을 반환받은 후 인덱스 값이 정상이면, 인덱스값을 기준으로 문자열 t를 slice 한다.
계속 문자열을 자르기 때문에 앞에서 찾은 문자보다 후 순위에 있는 문자는 앞에서 찾은 위치 이후부터 찾을 수 있게 된다.
문자열을 계속 자르는 방식을 이용하여 subsequence를 구현했다.

space complexity: O(1)
- 인덱스 저장을 위한 변수 a를 사용한다

time complexity: O(N)
- s는 최대 100이고 t의 길이를 N이라고 한다면 최대 O(100*N)이 걸리게 된다.


solution:

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i, j = 0, 0
        n = len(s)
        m = len(t)
        
        while (i < n and j < m):
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == n
```
문자열 s와 t의 인덱스 값을 증가시키면서 같은 문자가 있는지 탐색하는 알고리즘이다.
slice를 하지 않고 인덱스 값을 증가시키는 것으로 slice를 대체한다.
s의 인덱스는 찾았을 때만 증가하고 t는 계속 증가하기 때문에 다 찾기 전에 루프가 종료되면
s의 인덱스 값은 문자열 s의 길이보다 작게 되는 것을 이용하여 판별한다.

space complexity: O(1)
- 문자열의 길이를 저장하기 위핸 변수 2개를 사용한다

time complexity: O(N)
- while 문은 최대 t의 길이만큼 반복된다. 따라서 최대 O(N)